<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8" />
    <script>
        // Including $script.js inline here to avoid delaying the load
        (function (name, definition) {
            if (typeof module != 'undefined' && module.exports) module.exports = definition()
            else if (typeof define == 'function' && define.amd) define(definition)
            else this[name] = definition()
        })('$script', function () {
            var doc = document
              , head = doc.getElementsByTagName('head')[0]
              , s = 'string'
              , f = false
              , push = 'push'
              , readyState = 'readyState'
              , onreadystatechange = 'onreadystatechange'
              , list = {}
              , ids = {}
              , delay = {}
              , scripts = {}
              , scriptpath
              , urlArgs

            function every(ar, fn) {
                for (var i = 0, j = ar.length; i < j; ++i) if (!fn(ar[i])) return f
                return 1
            }
            function each(ar, fn) {
                every(ar, function (el) {
                    return !fn(el)
                })
            }

            function $script(paths, idOrDone, optDone) {
                paths = paths[push] ? paths : [paths]
                var idOrDoneIsDone = idOrDone && idOrDone.call
                  , done = idOrDoneIsDone ? idOrDone : optDone
                  , id = idOrDoneIsDone ? paths.join('') : idOrDone
                  , queue = paths.length
                function loopFn(item) {
                    return item.call ? item() : list[item]
                }
                function callback() {
                    if (!--queue) {
                        list[id] = 1
                        done && done()
                        for (var dset in delay) {
                            every(dset.split('|'), loopFn) && !each(delay[dset], loopFn) && (delay[dset] = [])
                        }
                    }
                }
                setTimeout(function () {
                    each(paths, function loading(path, force) {
                        if (path === null) return callback()
                        path = !force && path.indexOf('.js') === -1 && !/^https?:\/\//.test(path) && scriptpath ? scriptpath + path + '.js' : path
                        if (scripts[path]) {
                            if (id) ids[id] = 1
                            return (scripts[path] == 2) ? callback() : setTimeout(function () { loading(path, true) }, 0)
                        }

                        scripts[path] = 1
                        if (id) ids[id] = 1
                        create(path, callback)
                    })
                }, 0)
                return $script
            }

            function create(path, fn) {
                var el = doc.createElement('script'), loaded
                el.onload = el.onerror = el[onreadystatechange] = function () {
                    if ((el[readyState] && !(/^c|loade/.test(el[readyState]))) || loaded) return;
                    el.onload = el[onreadystatechange] = null
                    loaded = 1
                    scripts[path] = 2
                    fn()
                }
                el.async = 1
                el.src = urlArgs ? path + (path.indexOf('?') === -1 ? '?' : '&') + urlArgs : path;
                head.insertBefore(el, head.lastChild)
            }

            $script.get = create

            $script.order = function (scripts, id, done) {
                (function callback(s) {
                    s = scripts.shift()
                    !scripts.length ? $script(s, id, done) : $script(s, callback)
                }())
            }

            $script.path = function (p) {
                scriptpath = p
            }
            $script.urlArgs = function (str) {
                urlArgs = str;
            }
            $script.ready = function (deps, ready, req) {
                deps = deps[push] ? deps : [deps]
                var missing = [];
                !each(deps, function (dep) {
                    list[dep] || missing[push](dep);
                }) && every(deps, function (dep) { return list[dep] }) ?
                  ready() : !function (key) {
                      delay[key] = delay[key] || []
                      delay[key][push](ready)
                      req && req(missing)
                  }(deps.join('|'))
                return $script
            }

            $script.done = function (idOrDone) {
                $script([null], idOrDone)
            }

            return $script
        });
    </script>

    <style type="text/css">
        #loading-overlay {
            height: 100%;
            width: 100%;
            position: fixed;
            z-index: 100;
            left: 0px;
            top: 0px;
        }
    </style>
</head>
<body>
    <canvas id="loading-overlay"></canvas>
    <script>
        "use strict";

        (function ()
        {
            var ArcLength = (function ()
            {
                var defaultMaxIterations = 16;
                var defaultDesiredAccuracy = 0.1;
                var defaultInitialSegments = 10;

                var calculateArcLength = function (func, start, end, segments)
                {
                    var len = 0;
                    var stepWidth = (end - start) / segments;

                    var currentX = start;
                    var currentY = func(start);
                    for (var i = 0; i < segments; i++)
                    {
                        var nextX = currentX + stepWidth;
                        var nextY = func(nextX);

                        len += Math.sqrt(Math.pow(nextX - currentX, 2) + Math.pow(nextY - currentY, 2));

                        currentX = nextX;
                        currentY = nextY;
                    }

                    return len;
                };

                var findArcLength = function (func, start, end, desiredAccuracy, maxIterations)
                {
                    maxIterations = maxIterations || defaultMaxIterations;
                    desiredAccuracy = desiredAccuracy || defaultDesiredAccuracy;

                    var currentSegments = defaultInitialSegments;
                    var length = calculateArcLength(func, start, end, currentSegments);
                    var previousLength;

                    var iterations = 0;

                    do
                    {
                        previousLength = length;
                        currentSegments *= 2;
                        length = calculateArcLength(func, start, end, currentSegments);
                    } while (Math.abs(length - previousLength) > desiredAccuracy && ++iterations <= maxIterations);

                    return length;
                };

                var findWidthWithArcLength = function (func, start, desiredLength, direction, desiredAccuracy, maxIterations)
                {
                    maxIterations = maxIterations || defaultMaxIterations;
                    desiredAccuracy = desiredAccuracy || defaultDesiredAccuracy;
                    direction = direction || 1;

                    var length = 0;
                    var end = start;

                    var increment = direction * desiredLength;

                    var iterations = 0;

                    do
                    {
                        if (length > desiredLength)
                        {
                            end -= increment;
                        }
                        else
                        {
                            end += increment;
                        }
                        increment /= 2;
                        length = findArcLength(func, start, end, desiredAccuracy, maxIterations);
                    } while (Math.abs(length - desiredLength) > desiredAccuracy && ++iterations <= maxIterations);

                    return Math.abs(end - start);
                };

                return {
                    findWidthWithArcLength: findWidthWithArcLength
                };
            }());

            var Canvas = (function() 
            {
                var drawFunction = function (context, func, startX, endX, segments)
                {
                    context.beginPath();

                    var current = startX;
                    var increment = (endX - startX) / segments;

                    context.moveTo(current, func(current));

                    for (var i = 0; i < segments; i++)
                    {
                        current += increment;
                        context.lineTo(current, func(current));
                    }

                    context.stroke();
                };

                var centerAndPixelAlign = function ()
                {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;

                    context.translate(canvas.width / 2, canvas.height / 2);
                    context.scale(1, -1);
                };

                var copyState = function (from, to)
                {
                    for (var p in from)
                    {
                        var val = from[p];
                        to[p] = (typeof val === 'function') ? val() : val;
                    }
                };

                return {
                    drawFunction: drawFunction,
                    copyState: copyState,
                    centerAndPixelAlign: centerAndPixelAlign
                };
            }());

            var Functions = (function ()
            {
                var gaussianCurve = function (height, mean, width)
                {
                    return function (x)
                    {
                        var h = (typeof height === 'function') ? height(x) : height;
                        var m = (typeof mean === 'function') ? mean(x) : mean;
                        var w = (typeof width === 'function') ? width(x) : width;
                        return h * Math.exp(-Math.pow(x - m, 2) / Math.pow(w / 2, 2));
                    };
                };

                var flattenedGaussianCurve = function (height, mean, width, flatteningFactor)
                {
                    return function (x)
                    {
                        var h = (typeof height === 'function') ? height(x) : height;
                        var m = (typeof mean === 'function') ? mean(x) : mean;
                        var w = (typeof width === 'function') ? width(x) : width;
                        var f = (typeof flatteningFactor === 'function') ? flatteningFactor(x) : flatteningFactor;
                        return h * Math.exp(-Math.pow(Math.abs(x - m), 2 * f) / Math.pow(w / 2, 2 * f));
                    };
                }

                var sinusoid = function (height, wavelength, position)
                {
                    return function (x)
                    {
                        var h = (typeof height === 'function') ? height(x) : height;
                        var l = (typeof wavelength === 'function') ? wavelength(x) : wavelength;
                        var p = (typeof position === 'function') ? position(x) : position;
                        return h * Math.cos(2 * Math.PI * (x - p) / l);
                    };
                };

                return {
                    gaussianCurve: gaussianCurve,
                    flattenedGaussianCurve: flattenedGaussianCurve,
                    sinusoid: sinusoid
                }
            }());

            var AnimatedRepeater = function (start, lowerBound, upperBound, increment, timeInterval)
            {
                var value = start;
                var timer = null;
                var width = upperBound - lowerBound;

                var tick = function ()
                {
                    value += (typeof increment === 'function') ? increment(value) : increment;
                    if (value < lowerBound)
                    {
                        value += width;
                    }
                    if (value >= upperBound)
                    {
                        value -= width;
                    }
                };

                return {
                    getValue: function () 
                    {
                        return value;
                    },
                    start: function ()
                    {
                        timer = window.setInterval(tick, timeInterval);
                    },
                    stop: function ()
                    {
                        timer.stop();
                        timer = null;
                    }
                };
            };

            var canvas = document.getElementById('loading-overlay');
            var context = canvas.getContext('2d');
            
            var scale = 1;

            var trackHeight = 60; // pixels
            var trackWidth = 800; // pixels
            var trackSegments = 500;

            var frameInterval = 30; // ms

            var waveSpeed = -110; // pixels / s
            var waveWavelength = 54; // pixels

            var pulseSpeed = -85; // pixels / s
            var pulseWidth = 120; // pixels
            
            var wormLength = 150; // pixels
            var wormSpeed = 200; // pixels / s
            var wormSegments = 200;
            var wormOverflow = 25; // pixels
            var wormColor1 = '#2255cc';
            var wormColor2 = '#0044aa';
            var wormRadius1 = 2; // pixels
            var wormRadius2 = 50; // pixels
            
            var textValues = ['Loading .', 'Loading ..', 'Loading ...'];

            var textContextState = {
                textAlign: 'left',
                font: 'bold 30px "Lucida Sans Unicode", "Lucida Grande", sans-serif',
                fillStyle: 'black',
                shadowBlur: function () { return 2 * scale; },
                shadowColor: '#999999',
                shadowOffsetX: function () { return scale; },
                shadowOffsetY: function () { return scale; }
            };

            var trackContextState = {
                lineWidth: 7,
                lineCap: 'round',
                strokeStyle: '#D8D8D8'
            };

            var wormContextState = {
                lineWidth: 11,
                lineCap: 'round',
                shadowColor: '#555555',
                shadowBlur: function () { return 5 * scale; },
                shadowOffsetX: function () { return -3 * scale; },
                shadowOffsetY: function () { return 3 * scale; }
            };

            var trackStart = -trackWidth / 2;
            var trackEnd = trackWidth / 2;

            var wormStart = trackStart - wormOverflow;
            var wormEnd = trackEnd + wormLength + wormOverflow;
            
            var perSecondToPerFrame = function (valuePerSecond, frameInterval)
            {
                return valuePerSecond * frameInterval / 1000;
            };
            
            var pulsePosition = new AnimatedRepeater(trackEnd + pulseWidth, trackStart - pulseWidth, trackEnd + pulseWidth, perSecondToPerFrame(pulseSpeed, frameInterval), frameInterval);
            var wavePosition = new AnimatedRepeater(0, 0, waveWavelength, perSecondToPerFrame(waveSpeed, frameInterval), frameInterval);
            var textIndex = new AnimatedRepeater(0, 0, 3, 1, 1000);

            var pulseFunc = Functions.flattenedGaussianCurve(trackHeight, pulsePosition.getValue, pulseWidth, 1.3);
            var trackFunction = Functions.sinusoid(pulseFunc, waveWavelength, wavePosition.getValue);

            var wormIncrement = function (current)
            {
                return ArcLength.findWidthWithArcLength(trackFunction, current, perSecondToPerFrame(wormSpeed, frameInterval));
            };

            var wormPosition = new AnimatedRepeater(wormStart, wormStart, wormEnd, wormIncrement, frameInterval);
            
            wormContextState.strokeStyle = function ()
            {
                var pos = {
                    x: wormPosition.getValue(),
                    y: trackFunction(wormPosition.getValue())
                };

                var gradient = context.createRadialGradient(pos.x, pos.y, wormRadius1, pos.x, pos.y, wormRadius2);
                gradient.addColorStop(0, wormColor1);
                gradient.addColorStop(1, wormColor2);
                return gradient;
            };

            var drawText = function ()
            {
                context.save();

                context.scale(1, -1);

                Canvas.copyState(textContextState, context);

                var width = context.measureText(textValues[textValues.length - 1]).width;
                context.fillText(textValues[textIndex.getValue()], -width / 2, 35);

                context.restore();
            }

            var drawTrack = function ()
            {
                context.save();
                Canvas.copyState(trackContextState, context);

                Canvas.drawFunction(context, trackFunction, trackStart, trackEnd, trackSegments);
                context.restore();
            };

            var drawWorm = function ()
            {
                var width = ArcLength.findWidthWithArcLength(trackFunction, wormPosition.getValue(), wormLength, -1);

                var start = Math.max(trackStart, wormPosition.getValue() - width);
                var end = Math.min(trackEnd, wormPosition.getValue());

                if (trackStart < end && start < trackEnd)
                {
                    context.save();
                    context.translate(-wormContextState.shadowOffsetX() || 0, wormContextState.shadowOffsetY() || 0);

                    Canvas.copyState(wormContextState, context);

                    Canvas.drawFunction(context, trackFunction, start, end, wormSegments);
                    context.restore();
                }
            }

            var draw = function ()
            {
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.save();

                Canvas.centerAndPixelAlign();

                scale = 1;
                while (trackWidth * scale > canvas.width * 0.6666)
                {
                    scale *= 0.75;
                }

                context.scale(scale, scale);

                drawText();

                context.translate(0, trackHeight);

                drawTrack();

                drawWorm();

                context.restore();
            };

            var animationInterval = window.setInterval(draw, animationInterval);
            pulsePosition.start();
            wavePosition.start();
            wormPosition.start();
            textIndex.start();

            var previousOnLoad = window.onload;
            window.onload = function ()
            {
                if (typeof previousOnLoad === 'function')
                {
                    previousOnLoad();
                }
                /*
                window.setTimeout(function () 
                {
                    window.clearInterval(animationInterval);
                    pulsePosition.stop();
                    wavePosition.stop();
                    wormPosition.stop();
                    textIndex.stop();
                }, 2000);*/
            };
        }());
    </script>
</body>
</html>
